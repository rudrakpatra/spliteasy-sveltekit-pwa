// trpc/routers/group.ts
import { z } from "zod";
import { and, eq, sql } from "drizzle-orm";
import { TRPCError } from "@trpc/server";
import { protectedProcedure, t } from "../init";
import {
    groups,
    groupMembers,
    users,
    expenseSplits,
    expenses,
    groupsSelectSchema,
} from "$lib/server/db/schema";
import { uuidSchema, type Uuid } from "$lib/shared/schema/uuid";
import { userIdSchema, type UserId } from "$lib/shared/schema/user";
import { ensureGroupMember, getGroupMemberIds } from "./utils";
import { MAX_GROUP_MEMBERS } from "$lib/constants";
import type { CurrencyCode } from "$lib/shared/currency/currency-codes";
import type { NumberString } from "$lib/shared/schema/math";


export const insertGroupSchema = groupsSelectSchema.extend({
    members: z.array(z.string()),
}).omit({
    //omit these fields as they are auto generated by server
    id: true,
    createdAt: true,
    updatedAt: true,
});

export const updateGroupSchema = groupsSelectSchema.omit({
    //omit these fields as they are auto generated by server
    id: true,
    createdAt: true,
    updatedAt: true,
});

export const groupRouter = t.router({
    // List all groups for current user
    list: protectedProcedure
        .input(z.object({
            limit: z.number().default(20),
            offset: z.number().default(0),
        }))
        .query(async ({ input, ctx }) => {
            const rows = await ctx.db
                .select({
                    groups,
                    total: sql<number>`count(*) OVER ()`,
                })
                .from(groups)
                .innerJoin(groupMembers, eq(groups.id, groupMembers.groupId))
                .where(eq(groupMembers.userId, ctx.user.id))
                .limit(input.limit)
                .offset(input.offset);

            const items = rows.map((r) => r.groups);
            const total = rows[0]?.total ?? 0;

            return {
                items,
                total,
                limit: input.limit,
                offset: input.offset,
                hasMore: input.offset + items.length < total,
            };
        }),

    // Insert group
    insert: protectedProcedure
        .input(insertGroupSchema)
        .mutation(async ({ input, ctx }) => {
            return await ctx.db.transaction(async (tx) => {
                const [newGroup] = await tx
                    .insert(groups)
                    .values({
                        name: input.name,
                        img: input.img || `https://api.dicebear.com/7.x/shapes/svg?seed=${input.name}`,
                    })
                    .returning();

                const [member] = await tx
                    .insert(groupMembers)
                    .values({ groupId: newGroup.id, userId: ctx.user.id })
                    .onConflictDoNothing()
                    .returning();

                return {
                    ...newGroup,
                    members: [member],
                };
            });
        }),

    // Update group
    update: protectedProcedure
        .input(z.object({
            groupId: z.string(),
            name: z.string().optional(),
            img: z.string().optional(),
        }))
        .mutation(async ({ input, ctx }) => {
            const groupId = uuidSchema.decode(input.groupId);

            await ensureGroupMember(ctx.db, groupId, ctx.user.id);

            const [updated] = await ctx.db
                .update(groups)
                .set({
                    name: input.name,
                    img: input.img,
                })
                .where(eq(groups.id, groupId))
                .returning();

            if (!updated) {
                throw new TRPCError({
                    code: 'NOT_FOUND',
                    message: 'Group not found or failed to update',
                });
            }

            return updated;
        }),

    // Get group by ID
    getById: protectedProcedure
        .input(z.object({ id: z.string() }))
        .query(async ({ input, ctx }) => {
            const id = uuidSchema.decode(input.id);
            const group = await ctx.db
                .select()
                .from(groups)
                .where(eq(groups.id, id))
                .limit(1);

            if (!group[0]) {
                throw new TRPCError({
                    code: 'NOT_FOUND',
                    message: 'Group not found',
                });
            }

            return group[0];
        }),

    // Get group members
    getMembers: protectedProcedure
        .input(z.object({ groupId: z.string() }))
        .query(async ({ input, ctx }) => {
            const groupId = uuidSchema.decode(input.groupId);
            console.log(groupId);
            const rows = await ctx.db
                .select({
                    user: users,
                    member: groupMembers,
                })
                .from(groupMembers)
                .innerJoin(users, eq(groupMembers.userId, users.id))
                .where(eq(groupMembers.groupId, groupId))
                .orderBy(users.name);

            const result = rows.map((row) => ({
                ...row.member,
                user: row.user,
            }));
            console.log(result);

            // Verify current user is a member
            if (!result.find((r) => r.userId === ctx.user.id)) {
                throw new TRPCError({
                    code: 'FORBIDDEN',
                    message: 'Unauthorized',
                });
            }

            return result;
        }),

    // Add member to group (only existing members can add)
    addMember: protectedProcedure
        .input(z.object({
            groupId: z.string(),
            userId: z.string()
        }))
        .mutation(async ({ input, ctx }) => {
            const groupId = uuidSchema.decode(input.groupId);
            const userId = userIdSchema.decode(input.userId);

            // Check existing members
            const existingMemberIds = await getGroupMemberIds(ctx.db, groupId);

            if (existingMemberIds.includes(userId)) {
                throw new TRPCError({
                    code: 'BAD_REQUEST',
                    message: 'User already exists in the group',
                });
            }

            if (existingMemberIds.length >= MAX_GROUP_MEMBERS) {
                throw new TRPCError({
                    code: 'BAD_REQUEST',
                    message: 'Group has reached the maximum number of members',
                });
            }

            // Only existing member can add
            await ensureGroupMember(ctx.db, groupId, ctx.user.id);

            // Verify target user exists
            const targetUser = await ctx.db
                .select()
                .from(users)
                .where(eq(users.id, userId))
                .limit(1);

            if (!targetUser.length) {
                throw new TRPCError({
                    code: 'NOT_FOUND',
                    message: 'User not found',
                });
            }

            await ctx.db
                .insert(groupMembers)
                .values({ groupId, userId })
                .onConflictDoNothing();

            return { success: true };
        }),

    // Leave group (remove self from group)
    leave: protectedProcedure
        .input(z.object({ groupId: z.string() }))
        .mutation(async ({ input, ctx }) => {
            const groupId = uuidSchema.decode(input.groupId);

            await ensureGroupMember(ctx.db, groupId, ctx.user.id);

            // Check for zero balance
            const balances = await getGroupBalances(ctx.db, groupId, ctx.user.id);
            const userBalances = balances[ctx.user.id];

            if (userBalances) {
                const hasNonZeroBalance = Object.values(userBalances).some(
                    (balance) => parseFloat(balance) !== 0,
                );
                if (hasNonZeroBalance) {
                    throw new TRPCError({
                        code: 'PRECONDITION_FAILED',
                        message: 'Cannot leave group with outstanding balance. Please settle your debts first.',
                    });
                }
            }

            // Check for pending approvals
            const pendingApprovals = await ctx.db
                .select({ expenseId: expenseSplits.expenseId })
                .from(expenseSplits)
                .where(
                    and(
                        eq(expenseSplits.groupId, groupId),
                        eq(expenseSplits.userId, ctx.user.id),
                        eq(expenseSplits.isApproved, false),
                    ),
                )
                .limit(1);

            if (pendingApprovals.length > 0) {
                throw new TRPCError({
                    code: 'PRECONDITION_FAILED',
                    message: 'Cannot leave group while you have pending expense approvals.',
                });
            }

            await ctx.db
                .delete(groupMembers)
                .where(
                    and(
                        eq(groupMembers.groupId, groupId),
                        eq(groupMembers.userId, ctx.user.id),
                    ),
                );

            return { success: true };
        }),

    // Delete group (only group owner can delete)
    delete: protectedProcedure
        .input(z.object({ groupId: z.string() }))
        .mutation(async ({ input, ctx }) => {
            const groupId = uuidSchema.decode(input.groupId);

            await ensureGroupMember(ctx.db, groupId, ctx.user.id);

            // Check all balances are zero
            const balances = await getGroupBalances(ctx.db, groupId, ctx.user.id);
            const nonZeroBalances = Object.entries(balances).filter(
                ([_, userBalances]) =>
                    Object.values(userBalances).some((balance) => parseFloat(balance) !== 0),
            );

            if (nonZeroBalances.length > 0) {
                const userIds = nonZeroBalances.map(([userId]) => userId);
                throw new TRPCError({
                    code: 'PRECONDITION_FAILED',
                    message: `Cannot delete group. Users ${userIds.join(', ')} have outstanding balances.`,
                });
            }

            // Check for pending expenses
            const pendingExpenses = await ctx.db
                .select({ id: expenses.id })
                .from(expenses)
                .where(
                    and(
                        eq(expenses.groupId, groupId),
                        sql`EXISTS (
              SELECT 1 FROM expense_splits es2
              WHERE es2.expense_id = ${expenses}.id 
              AND es2.is_approved = false
            )`,
                    ),
                )
                .limit(1);

            if (pendingExpenses.length > 0) {
                throw new TRPCError({
                    code: 'PRECONDITION_FAILED',
                    message: 'Cannot delete group with pending expense approvals.',
                });
            }

            return await ctx.db.transaction(async (tx) => {
                await tx.delete(groupMembers).where(eq(groupMembers.groupId, groupId));
                const deleted = await tx
                    .delete(groups)
                    .where(eq(groups.id, groupId))
                    .returning();

                if (deleted.length === 0) {
                    throw new TRPCError({
                        code: 'INTERNAL_SERVER_ERROR',
                        message: 'Failed to delete group',
                    });
                }

                return { id: groupId };
            });
        }),

    // Get group balances
    getBalances: protectedProcedure
        .input(z.object({ groupId: z.string() }))
        .query(async ({ input, ctx }) => {
            const groupId = uuidSchema.decode(input.groupId);
            return await getGroupBalances(ctx.db, groupId, ctx.user.id);
        }),
});
/**
 * Only consider splits from this group and only approved ones.
 * Include only expenses where ALL splits are approved (NOT EXISTS any unapproved for that expense).
 * Compute per-user per-currency (paid - owes).
 * @param db 
 * @param groupId 
 * @param userId 
 * @returns 
 */
async function getGroupBalances(
    db: typeof import("$lib/server/db").db,
    groupId: Uuid,
    userId: UserId,
): Promise<Record<string, Record<CurrencyCode, NumberString>>> {
    const rows = await db
        .select({
            userId: expenseSplits.userId,
            currency: expenseSplits.currency,
            balance: sql<NumberString>`SUM((${expenseSplits}.paid_amount::numeric - ${expenseSplits}.owes_amount::numeric))::text`,
        })
        .from(expenseSplits)
        .innerJoin(
            groupMembers,
            and(
                eq(groupMembers.groupId, expenseSplits.groupId),
                eq(groupMembers.userId, expenseSplits.userId),
            ),
        )
        .where(
            and(
                eq(expenseSplits.groupId, groupId),
                eq(expenseSplits.isApproved, true),
                sql`NOT EXISTS (
      SELECT 1 FROM expense_splits es2
      WHERE es2.expense_id = ${expenseSplits}.expense_id AND es2.is_approved = false
    )`,
            ),
        )
        .groupBy(expenseSplits.userId, expenseSplits.currency);

    // Must be a member to view
    if (!rows.find((r) => r.userId === userId)) {
        throw new TRPCError({
            code: 'FORBIDDEN',
            message: 'Unauthorized',
        });
    }

    const result: Record<string, Record<CurrencyCode, NumberString>> = {};
    for (const row of rows) {
        if (!result[row.userId]) result[row.userId] = {} as Record<CurrencyCode, NumberString>;
        result[row.userId][row.currency] = row.balance;
    }
    return result;
}

