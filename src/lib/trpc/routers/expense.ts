// trpc/routers/expense.ts
import { z } from "zod";
import { and, desc, eq, sql } from "drizzle-orm";
import { TRPCError } from "@trpc/server";
import { protectedProcedure, t } from "../init";
import { type NumberString } from "$lib/shared/schema/math";
import { userIdSchema } from "$lib/shared/schema/user";
import { ensureGroupMember, getGroupMemberIds, sqlIsGroupMember } from "./utils";
import { expenses, expensesInsertSchema, expenseSplits, expenseSplitsInsertSchema, expenseSplitsSelectSchema, expensesSelectSchema } from "$lib/server/db/schema";
import { uuidSchema } from "$lib/shared/schema/uuid";

//router schemas written separately to write transformers
export const insertExpenseInputSchema = expensesInsertSchema.extend({
    splits: z.array(expenseSplitsInsertSchema.omit({
        //omit these fields as they are auto generated by server
        expenseId: true,
        groupId: true,
        approvalTime: true,
        isApproved: true,
    })),
}).omit({
    //omit these fields as they are auto generated by server
    id: true,
    createdAt: true,
    updatedAt: true,
    updatedBy: true,
});

export type InsertInput = z.infer<typeof insertExpenseInputSchema>;
export const updateExpenseInputSchema = insertExpenseInputSchema.extend({
    id: uuidSchema, //required for update,
});

export const expenseRouter = t.router({
    select: protectedProcedure
        .input(z.object({ expenseId: z.string() }))
        .query(async ({ input, ctx }) => {
            const expenseId = uuidSchema.decode(input.expenseId)
            const [expense] = await ctx.db
                .select()
                .from(expenses)
                .where(eq(expenses.id, expenseId))
                .limit(1);

            if (!expense) {
                throw new TRPCError({
                    code: 'NOT_FOUND',
                    message: 'Expense not found',
                });
            }

            return expense;
        }),
    insert: protectedProcedure
        .input(insertExpenseInputSchema)
        .mutation(async ({ input, ctx }) => {
            const groupId = uuidSchema.decode(input.groupId);

            return await ctx.db.transaction(async (tx) => {
                // Verify membership and participants
                const memberIds = await getGroupMemberIds(tx, groupId);
                if (!memberIds.includes(ctx.user.id)) {
                    throw new TRPCError({
                        code: 'FORBIDDEN',
                        message: 'You are not a member of this group',
                    });
                }

                // Validate all split participants are group members
                input.splits.forEach((split) => {
                    const splitUserId = userIdSchema.decode(split.userId);
                    if (!memberIds.includes(splitUserId)) {
                        throw new TRPCError({
                            code: 'BAD_REQUEST',
                            message: 'Expense participant is not a member of the group',
                        });
                    }
                });

                // Insert expense
                const [newExpense] = await tx
                    .insert(expenses)
                    .values({
                        name: input.name,
                        metadata: input.metadata,
                        groupId: groupId,
                        updatedBy: ctx.user.id,
                    })
                    .returning();

                // Insert splits with auto-approval for creator
                const splitsValues = input.splits.map((split) => ({
                    userId: userIdSchema.decode(split.userId),
                    currency: split.currency,
                    owesAmount: split.owesAmount as NumberString,
                    paidAmount: split.paidAmount as NumberString,
                    expenseId: newExpense.id,
                    groupId: groupId,
                    isApproved: userIdSchema.decode(split.userId) === ctx.user.id,
                    approvalTime: userIdSchema.decode(split.userId) === ctx.user.id ? sql`NOW()` : null,
                }));

                const createdSplits = await tx
                    .insert(expenseSplits)
                    .values(splitsValues)
                    .returning();

                return {
                    ...newExpense,
                    splits: createdSplits,
                };
            });
        }),

    // Update expense
    update: protectedProcedure
        .input(updateExpenseInputSchema)
        .mutation(async ({ input, ctx }) => {
            const expenseId = uuidSchema.decode(input.id);
            const groupId = uuidSchema.decode(input.groupId);

            // Load existing expense
            const [existing] = await ctx.db
                .select()
                .from(expenses)
                .where(eq(expenses.id, expenseId))
                .limit(1);

            if (!existing) {
                throw new TRPCError({
                    code: 'NOT_FOUND',
                    message: 'Expense not found',
                });
            }

            return await ctx.db.transaction(async (tx) => {
                // Verify membership
                await ensureGroupMember(tx, existing.groupId, ctx.user.id);

                const memberIds = await getGroupMemberIds(tx, groupId);
                if (!memberIds.includes(ctx.user.id)) {
                    throw new TRPCError({
                        code: 'FORBIDDEN',
                        message: 'Unauthorized',
                    });
                }

                // Validate participants
                input.splits.forEach((split) => {
                    const splitUserId = userIdSchema.decode(split.userId);
                    if (!memberIds.includes(splitUserId)) {
                        throw new TRPCError({
                            code: 'BAD_REQUEST',
                            message: 'Expense participant is not a member of the group',
                        });
                    }
                });

                // Update expense
                const [updatedExpense] = await tx
                    .update(expenses)
                    .set({
                        name: input.name ?? existing.name,
                        metadata: input.metadata ?? existing.metadata,
                        groupId: groupId ?? existing.groupId,
                        updatedBy: ctx.user.id,
                    })
                    .where(eq(expenses.id, expenseId))
                    .returning();

                if (!updatedExpense) {
                    throw new TRPCError({
                        code: 'INTERNAL_SERVER_ERROR',
                        message: 'Failed to update expense',
                    });
                }

                // Replace splits
                await tx.delete(expenseSplits).where(eq(expenseSplits.expenseId, expenseId));

                const splitsToInsert = input.splits.map((s) => ({
                    expenseId,
                    userId: userIdSchema.decode(s.userId),
                    groupId: groupId,
                    currency: s.currency,
                    owesAmount: s.owesAmount as NumberString,
                    paidAmount: s.paidAmount as NumberString,
                    isApproved: uuidSchema.decode(s.userId) === ctx.user.id,
                    approvalTime: uuidSchema.decode(s.userId) === ctx.user.id ? sql`NOW()` : null,
                }));

                const insertedSplits = await tx
                    .insert(expenseSplits)
                    .values(splitsToInsert)
                    .returning();

                return {
                    ...updatedExpense,
                    splits: insertedSplits,
                };
            });
        }),

    // Delete expense (only if not approved by user)
    delete: protectedProcedure
        .input(z.object({
            id: uuidSchema,
        }))
        .mutation(async ({ input, ctx }) => {
            const expenseId = uuidSchema.decode(input.id);

            // Get groupId for membership check
            const [row] = await ctx.db
                .select({ groupId: expenses.groupId })
                .from(expenses)
                .where(eq(expenses.id, expenseId))
                .limit(1);

            if (!row) {
                throw new TRPCError({
                    code: 'NOT_FOUND',
                    message: 'Expense not found',
                });
            }

            // Atomic delete with conditions
            const deleted = await ctx.db
                .delete(expenses)
                .where(
                    and(
                        eq(expenses.id, expenseId),
                        sqlIsGroupMember(expenses.groupId, ctx.user.id),
                        sql`NOT EXISTS (
              SELECT 1 FROM expense_splits es
              WHERE es.expense_id = ${expenseId} 
              AND es.is_approved = true 
              AND es.user_id = ${ctx.user.id}
            )`,
                    ),
                )
                .returning();

            if (deleted.length === 0) {
                throw new TRPCError({
                    code: 'FORBIDDEN',
                    message: 'Cannot delete a finalized expense or expense you have approved',
                });
            }

            return { id: expenseId };
        }),

    // Approve expense
    approve: protectedProcedure
        .input(z.object({ expenseId: z.string() }))
        .mutation(async ({ input, ctx }) => {
            const expenseId = uuidSchema.decode(input.expenseId);

            const updated = await ctx.db
                .update(expenseSplits)
                .set({
                    isApproved: true,
                    approvalTime: sql`COALESCE(${expenseSplits.approvalTime}, NOW())`,
                })
                .where(
                    and(
                        eq(expenseSplits.expenseId, expenseId),
                        eq(expenseSplits.userId, ctx.user.id),
                        sqlIsGroupMember(expenses.groupId, ctx.user.id),
                    ),
                )
                .returning({
                    groupId: sql<string>`(SELECT e.group_id FROM expenses e WHERE e.id = ${expenseSplits}.expense_id LIMIT 1)`,
                    approvedCount: sql<number>`(SELECT count(*) FROM expense_splits es WHERE es.expense_id = ${expenseSplits}.expense_id AND es.is_approved = true)`,
                    totalCount: sql<number>`(SELECT count(*) FROM expense_splits es WHERE es.expense_id = ${expenseSplits}.expense_id)`,
                });

            if (updated.length === 0) {
                return {
                    id: expenseId,
                    didChange: false,
                    isFullyApproved: false
                };
            }

            const { groupId, approvedCount, totalCount } = updated[0];

            return {
                id: expenseId,
                groupId,
                didChange: true,
                approvedCount,
                totalCount,
                isFullyApproved: approvedCount === totalCount,
            };
        }),

    // Get single expense with splits
    getById: protectedProcedure
        .input(z.object({ id: z.string() }))
        .query(async ({ input, ctx }) => {
            const expenseId = uuidSchema.decode(input.id);

            const rows = await ctx.db
                .select({
                    expense: expenses,
                    splitsJson: sql<any>`
            COALESCE(
              json_agg(${expenseSplits}.*) FILTER (WHERE ${expenseSplits}.expense_id IS NOT NULL),
              '[]'::json
            )
          `,
                })
                .from(expenses)
                .leftJoin(expenseSplits, eq(expenseSplits.expenseId, expenses.id))
                .where(eq(expenses.id, expenseId))
                .groupBy(expenses.id)
                .limit(1);

            if (!rows.length) {
                throw new TRPCError({
                    code: 'NOT_FOUND',
                    message: 'Expense not found',
                });
            }

            const { expense, splitsJson } = rows[0];
            const splits = z.array(expenseSplitsSelectSchema).parse(splitsJson);

            // Verify user is a participant
            if (!splits.find((s) => s.userId === ctx.user.id)) {
                throw new TRPCError({
                    code: 'FORBIDDEN',
                    message: 'Unauthorized',
                });
            }

            return {
                ...expensesSelectSchema.parse(expense),
                splits,
            };
        }),

    // Get finalized expenses for a group
    getFinalized: protectedProcedure
        .input(z.object({
            groupId: z.string(),
            limit: z.number().default(20),
            offset: z.number().default(0),
        }))
        .query(async ({ input, ctx }) => {
            const groupId = uuidSchema.decode(input.groupId);

            // Verify membership
            await ensureGroupMember(ctx.db, groupId, ctx.user.id);

            const rows = await ctx.db
                .select({
                    expense: expenses,
                    splitsJson: sql<any>`
            COALESCE(
              json_agg(${expenseSplits}.*) FILTER (WHERE ${expenseSplits}.expense_id IS NOT NULL),
              '[]'::json
            )
          `,
                    total: sql<number>`count(*) OVER ()`,
                })
                .from(expenses)
                .leftJoin(expenseSplits, eq(expenseSplits.expenseId, expenses.id))
                .where(
                    and(
                        eq(expenses.groupId, groupId),
                        // Finalized = all splits approved
                        sql`NOT EXISTS (
              SELECT 1 FROM expense_splits es2
              WHERE es2.expense_id = ${expenses}.id 
              AND es2.is_approved = false
            )`,
                    ),
                )
                .groupBy(expenses.id)
                .orderBy(desc(expenses.updatedAt))
                .limit(input.limit)
                .offset(input.offset);

            const items = rows.map((r) =>
                expensesSelectSchema.parse({
                    ...r.expense,
                    splits: (r.splitsJson as unknown[]) ?? [],
                }),
            );

            const total = rows[0]?.total ?? 0;

            return {
                items,
                total,
                limit: input.limit,
                offset: input.offset,
                hasMore: input.offset + items.length < total,
            };
        }),

    // Get proposed (pending) expenses for a group
    getProposed: protectedProcedure
        .input(z.object({
            groupId: z.string(),
            limit: z.number().default(20),
            offset: z.number().default(0),
        }))
        .query(async ({ input, ctx }) => {
            const groupId = uuidSchema.decode(input.groupId);

            await ensureGroupMember(ctx.db, groupId, ctx.user.id);

            const rows = await ctx.db
                .select({
                    expense: expenses,
                    splitsJson: sql<any>`
            COALESCE(
              json_agg(${expenseSplits}.*) FILTER (WHERE ${expenseSplits}.expense_id IS NOT NULL),
              '[]'::json
            )
          `,
                    total: sql<number>`count(*) OVER ()`,
                })
                .from(expenses)
                .leftJoin(expenseSplits, eq(expenseSplits.expenseId, expenses.id))
                .where(
                    and(
                        eq(expenses.groupId, groupId),
                        // Proposed = at least one unapproved split
                        sql`EXISTS (
              SELECT 1 FROM expense_splits es2
              WHERE es2.expense_id = ${expenses}.id 
              AND es2.is_approved = false
            )`,
                    ),
                )
                .groupBy(expenses.id)
                .orderBy(desc(expenses.updatedAt))
                .limit(input.limit)
                .offset(input.offset);

            const items = rows.map((r) =>
                expensesSelectSchema.parse({
                    ...r.expense,
                    splits: (r.splitsJson as unknown[]) ?? [],
                }),
            );

            const total = rows[0]?.total ?? 0;

            return {
                items,
                total,
                limit: input.limit,
                offset: input.offset,
                hasMore: input.offset + items.length < total,
            };
        }),
});
